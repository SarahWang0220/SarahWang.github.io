<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Test</title>
    <url>/2020/04/18/Test/</url>
    <content><![CDATA[<p>测试一下博客</p>
]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>做题记录</title>
    <url>/2020/04/26/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<ul>
<li><strong>codeforces1004D</strong><blockquote>
<p>大致算法： 构造<br>题目难度： 2200<br>题目连接： <a href="https://codeforces.com/contest/1004/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1004/problem/D</a><br>题目描述： 给你t个数字，要你组成一个n x m的矩阵，这个矩阵满足这样的条件 ①矩阵里面的元素到“0”这个元素的曼哈顿距离为元素值大小。曼哈顿距离：两个点坐标差的绝对值之和。现在问你的是输出n，m以及元素“0”的坐标(x,y);如果不存在这样的矩阵，输出“-1”。<br> 考虑对称性，故假设0点的(x,y)的x是最小的<br> 假设到左上角和右下角的曼哈顿距离是a和b，则满足如下条件</p>
<script type="math/tex; mode=display">
 \begin{cases}
 a + b = n + m - 2 \\
 x + y = a + b + 2 \\
 n * m = t \\
 \end{cases}</script><p> 因此可以枚举第一个不满足 cnt[i] = i的数字作为x <del>仔细想想为什么</del><br> 再枚举t的因子，求出n和m，进而验证是否可行</p>
</blockquote>
</li>
</ul>
<hr>
<ul>
<li><strong>codeforces1004E</strong><blockquote>
<p>大致算法： RMQ + 树的直径<br>题目难度： 2400<br>题目链接： <a href="https://codeforces.com/problemset/problem/1004/E" target="_blank" rel="noopener">https://codeforces.com/problemset/problem/1004/E</a><br>代码链接： </p>
</blockquote>
</li>
</ul>
<hr>
<ul>
<li><strong>codeforces1006F</strong><blockquote>
<p>大致算法： 双向dfs<br>题目难度:  2400<br>题目链接： <a href="https://codeforces.com/problemset/problem/1006/F" target="_blank" rel="noopener">https://codeforces.com/problemset/problem/1006/F</a><br>题目描述： 从左上走到右下，每次只能向右或下走，问走到右下角时路径异或和为k的路径数<br>矩阵大小为20 * 20，若统计全部路径则共有 2 ^40^ 种 <del>相当于长度为40的01串</del><br>若采用双向dfs, 则复杂度为 2 * 2 ^20^ \= 2 ^21^ </p>
</blockquote>
</li>
</ul>
<div><div class="fold_hider"><div class="close hider_title">**点这里看显示代码哦~**</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(x, st, en) for(int x = st; x &lt;= en; x++)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line">ll k;</span><br><span class="line">ll a[N][N];</span><br><span class="line"><span class="built_in">map</span>&lt;ll, ll&gt; dp[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, ll w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; n || y &gt; m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x + y == (n + m) / <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[x][w ^ a[x][y]]++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(x, y + <span class="number">1</span>, w ^ a[x][y]);</span><br><span class="line">    dfs1(x + <span class="number">1</span>, y, w ^ a[x][y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, ll w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">1</span> || y &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x + y == (n + m) / <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[x][k ^ w];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs2(x - <span class="number">1</span>, y, w ^ a[x][y]) + dfs2(x, y - <span class="number">1</span>, w ^ a[x][y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) rep(j, <span class="number">1</span>, m) <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dfs2(n, m, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<hr>
<p>更新ing</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
